# ROS Node

> 上一节我们从`turtlesim`仿真器开始，进一步的，探究ROS最基本的component，“Node/节点”；
>
> 阅读本节前请follow完课程课件或`wiki`的相关部分

```pdf
../../_media/Chapter%202%20WS-Package-Communication.pdf
```


- 不同的节点运行不同的程序，同时节点间需要通讯，交流数据来让整个系统有机运行；

- ROS提供的 “Topic/话题” 的通讯机制，是最常用的节点间通讯方法；




## 2.1 - Topic / 话题
rosrun打开turtlesim_node，再打开turtle_teleop_key（上一节最后讲的操作）:


现在我们想知道，这两个节点之间怎么进行数据交流的。可以使用ROS中一个好用的可视化工具：rqt_graph！(没装rqt_graph的话安装一下)

```
$ rqt_graph
```

![](https://gitee.com/SeaHIPage/My_Pics/raw/master/from_ubuntu/image.png)

圆圈画的为节点，你细品......



>  `/turtle1`是话题，`/cmd_vel`是运动信息，通过Topic发布的数据是在Topic下面挂着的；




<br>

### **Topic机制的Components**
<br>

1. **发布者（Publisher）**
   1. **节点**通过发布者将消息发送到特定的Topic上。一个节点可以有多个发布者，每个发布者都可以在不同时间发布不同类型的消息
   2. *teleop_turtle* *就充当publisher角色*


2. **订阅者（Subscriber）**
   1. **节点**通过订阅者从Topic上接收消息。与发布者类似，一个节点可以有多个订阅者，每个订阅者可以接收不同类型的消息
   2. *turtlesim就充当subscriber角色*


3. **消息（Message）**
   1. 消息是特定类型的数据，由用户自定义。可以是常见的数据类型（如整数、浮点数等），也可以是复杂的数据结构（如数组、结构体等）
   2. *Message的数据结构必须严格遵循ROS的规范，要么使用ROS规定的数据结构类型，如geometry_msgs, std_msgs等；同时也**可以自定义数据结构，编写后缀为`.msg`的文件来描述自定义的msg数据结构**，参见wiki或者自行查阅用法*
   3. *使用`rosmag`指令可以快捷查询ROS包中的消息类型和具体信息*

<br>

如果有读者好奇为什么这么设计，我会说......因为优雅，好用，方便区分不同的message信息；

其实`topic`相当于给予了`message`命名空间，方便管理；


<br>

### **Topic机制的workflow**

> 当一个节点发布消息时，它会将消息发送给`ROS Master`，并指定消息所属的`Topic`。同时，ROS Master会将这个消息的信息（包括消息类型）广播给所有的订阅者。订阅者收到广播后，可以根据消息类型进行处理。
>
> **简而言之：publisher就“嗯发”，subscriber想收哪个`Topic`的消息的话就嗯收；**
>
> 因此，常说Topic通讯机制是一种 **“一对多”** 的通讯机制，多个不同的subscriber可以订阅同一个publisher；
>



<br>
<br>


### **Pros & Cons**

以下是我让ChatGPT写的一些关于`Topic`通讯机制的优缺点，我觉得它说得**对对对对对对**：

---

*ROS Topic是一种发布-订阅（Publish-Subscribe）通信模式，允许不同部分的ROS节点之间以异步的方式交换信息。以下是ROS Topic相对于其他ROS通信方式的优势和劣势：*



- **ROS Topic的优势：**

  - **异步通信：** ROS Topic支持异步通信，节点可以发布消息而不需要等待接收者。这对于需要高度并行化的系统非常有用，因为节点可以继续执行其他任务而无需等待消息响应。

  - **多对多通信**： 多个节点可以同时订阅同一个ROS Topic，这种多对多通信模式适用于广播信息给多个接收者的情况，例如传感器数据。

  - **松散耦合的节点：** 由于ROS Topic的消息传递方式，节点之间的接口相对简单，这使得在不同项目中重复使用节点变得更加容易，因为节点可以独立开发和测试。

  - **消息类型多样性：** ROS Topic支持多种不同类型的消息，这使得它适用于各种不同的应用场景，从简单的文本消息到复杂的传感器数据。


- **ROS Topic的劣势：**

  - **不适合高带宽实时通信：** ROS Topic的消息传递机制对于需要低延迟和高带宽的实时通信不太适用。对于这些应用，ROS中的服务（Services）和动作（Actions）可能更合适，因为它们提供了直接的请求-响应机制。

  - **消息丢失风险：** 由于ROS Topic是异步的，消息可能会丢失，尤其是在网络不稳定或高负载情况下。因此，在需要可靠通信的应用中，需要考虑其他通信方式或添加额外的机制来确保消息的可靠性。

  - **复杂性：** 在处理多个节点之间的复杂通信关系时，可能需要更多的管理和调试工作，以确保消息正确地传递和处理。

*总之，ROS Topic是ROS中一种强大的通信方式，适用于许多机器人和自动化应用。然而，它不是适用于所有情况的通信方式，因此在设计ROS系统时，需要根据具体的需求和性能要求选择合适的通信方式。*

---


<br>

## 2.2 - Service / 服务
<br>

### **From "Topic" to "Service"**
<br>

使用`Topic`机制，相当于要不停的发发发和收收收，适合需要进行密集信息交流的场景；如自动驾驶的时候获取传感器的信息，毕竟传感器信息流要是断了可能小命不保；

*又比如我现在有一个任务场景，一台follower机械臂和一台leader机械臂，follower需要跟踪leader的关节角度，即leader干啥follower也要跟着干啥，leader需要不停发自己的关节角数据，follower需要不停接受leader的关节角数据；那么此时，使用`Topic`机制就很合理；*

*这个时候，如果用ROS1实现这个任务，大概率会寄了；*

- *一方面请读者想想，如果只是需要实现这个单一场景下的功能，写一个python脚本或者c++程序是不是就可以实现，无需实用体积更庞大的ROS，不论使用ROS1还是ROS2；*
- *另一方面，ROS1的实时性真的很差......*

*因此，这个例子告诉我们一个道理，并不是所有的应用都非用ROS不可，我们永远是针对具体情况具体分析；ROS只是给我们提供了一个较为通用的解，但这个解并不一定好；*

*我“有个朋友”就用ROS1干过类似的事情，踩了雷；*




回归正题，一些场景下我们其实并不需要`Topic`机制这样密集的信息交换，此时`Service`机制站了出来；

`Service`机制正如其名：“服务”；你有一天很累，到晚上了脚都走不动路了，于是去点了一个**“按脚服务”**；按完了感觉还没到位，于是你选择了**“加钟”**......



<br>

**“服务总在你需要的时候出现，因此只要你清楚什么时候需要服务，需要的时候去点个服务就可以了；”**

---

<br>



<br>


### **Service机制的Components**

<br>

1. **服务器端（Server）**：
   1. 提供“服务”的**节点**
   2. *类似洗脚城、按摩店的角色*


2. **客户端（Client）**
   1. 订阅“服务”的**节点**
   2. *我走路走累了去按个脚，我在这个环节中就是一个client节点*


3. **srv文件的定义**
   1. Service机制通过在ROS包中定义服务文件来定义服务，后缀为`.srv`服务文件通常包括两部分：请求（Request）和响应（Response）定义。详细参见 wiki 或者自行查阅用法
   2. *`Request`有点像你在编程的时候，编写一个function中的输入变量，在洗脚这个例子中可以是我下的订单；`Response`类似在编写一个function中需要return的变量，在洗脚这个例子中可以定义为我的状态：`按爽了` or `没按爽`, 如果`Response`是`没按爽`的话，再发起一次服务请求加个钟；*
   3. *请求描述了客户端希望发送的数据，响应描述了服务器将回复的数据。*

<br>



<br>


### **Pros & Cons**

以下是我让ChatGPT写的一些关于`Service`通讯机制的优缺点，我觉得它说得**好好好好好好**：

---

- **ROS Service的优势：**

  - **简单易用：** ROS的Service机制相对简单，易于理解和实现。这使得它成为快速建立节点间通信的良好选择，尤其适用于请求-响应式的通信模式。

  - **强类型：** Service机制使用强类型数据，通过服务定义文件明确定义请求和响应的数据结构。这有助于减少通信错误和提高代码的可维护性。
  
  - **同步通信：** Service机制提供同步通信，客户端发送请求后会等待服务器的响应，这使得控制流更容易管理。

  - **适用于小规模系统：** 对于小规模机器人系统或任务，Service机制通常足够满足需求，并且无需引入复杂的通信结构。

  - **易于调试：** 由于同步通信和明确定义的数据结构，Service机制在调试时通常更容易跟踪问题。


- **ROS Topic的劣势：**

  - **不适用于高频通信：** 由于同步通信的特性，Service机制不适用于需要高频率数据传输的应用。它更适用于低频请求-响应交互。

  - **通信开销：** Service机制引入了额外的通信开销，包括请求和响应的序列化和反序列化，这可能会在大规模系统中引起性能问题。

  - **阻塞式调用：** 由于客户端的阻塞式调用方式，如果服务器响应时间很长，可能会导致客户端被阻塞，影响系统的响应性。

  - **不适合大规模分布式系统：** 对于大规模分布式机器人系统，Service机制可能不是最佳选择，因为它的同步性质和通信开销可能会引入不必要的复杂性和性能问题。

*综合考虑，ROS的Service机制适用于小规模或中等规模的机器人应用程序，特别是那些需要请求-响应通信模式的情况。对于大规模系统或高频率通信需求，ROS还提供了其他通信机制，如ROS Topics和ROS Actions，可以更好地满足这些需求。选择合适的通信方式通常取决于应用程序的需求和性能要求。*

---


<br>






## 2.3 - Action / 











<br>
<br>
<br>

<center>
未完待续......
</center>

<center>

Last edited on September 24, 2023.
</center>

<br>
<br>
<br>
